import { NextResponse } from 'next/server';
import { getServerSession } from '../../../lib/session';
import { databaseHelpers } from '../../../lib/database';
import { handleApiError, handleValidationError, handleAuthError } from '../error-handler';
import { randomUUID } from 'crypto';

// Internal POST handler
async function handlePOST(request) {
  console.log('üîÑ Transfer API: Starting request processing');
  
  try {
    // Check database connection first
    if (!databaseHelpers.pool) {
      console.error('‚ùå Transfer API: Database pool not available');
      return handleApiError(new Error('Database connection not available'), 'Database connection failed');
    }

    // Test database connection
    try {
      await databaseHelpers.pool.query('SELECT 1');
      console.log('‚úÖ Transfer API: Database connection test successful');
    } catch (error) {
      console.error('‚ùå Transfer API: Database connection test failed:', error);
      return handleApiError(error, 'Database connection test failed');
    }

    const session = await getServerSession();
    console.log('üîç Transfer API: Session check', { 
      hasSession: !!session, 
      sessionId: session?.id, 
      sessionEmail: session?.email 
    });
    
    if (!session?.id) {
      console.log('‚ùå Transfer API: No session found');
      return handleAuthError('Authentication required');
    }

    // Parse and validate request body
    let requestData;
    try {
      requestData = await request.json();
      console.log('üìù Transfer API: Request data received', { 
        recipientEmail: requestData.recipientEmail,
        amount: requestData.amount,
        hasNote: !!requestData.note
      });
    } catch (error) {
      console.log('‚ùå Transfer API: JSON parsing failed', error.message);
      return handleValidationError('Invalid JSON in request body');
    }

    const { recipientEmail, amount, note } = requestData;

    // Validate input
    if (!recipientEmail || !amount) {
      return handleValidationError('Recipient email and amount are required');
    }

    // Validate amount
    const numericAmount = parseFloat(amount);
    if (isNaN(numericAmount) || numericAmount <= 0) {
      return handleValidationError('Amount must be a positive number');
    }

    // Validate Gmail format
    const gmailRegex = /^[a-zA-Z0-9._%+-]+@gmail\.com$/;
    if (!gmailRegex.test(recipientEmail)) {
      return handleValidationError('Please enter a valid Gmail address');
    }

    // Check if sender and recipient are the same
    if (session.email === recipientEmail) {
      return handleValidationError('You cannot send tokens to yourself');
    }

    // Use session data directly (for development/testing)
    const senderUser = {
      id: session.id,
      email: session.email,
      name: session.name || 'User',
      role: 'USER'
    };
    console.log('üîç Transfer API: Using session user:', senderUser);

    // For development/testing, use mock wallet data
    const senderWallet = {
      id: 'mock-wallet-id',
      userId: senderUser.id,
      VonBalance: 1000, // Mock balance for testing
      balance: 100
    };
    console.log('üîç Transfer API: Using mock sender wallet:', senderWallet);

    // Check sufficient balance
    if (senderWallet.VonBalance < numericAmount) {
      return handleValidationError('Insufficient Von balance');
    }

    // Use mock recipient for development/testing
    const recipient = {
      id: 'mock-recipient-id',
      email: recipientEmail,
      name: 'Test Recipient',
      role: 'USER'
    };
    console.log('üîç Transfer API: Using mock recipient:', recipient);

    // Use mock recipient wallet
    const recipientWallet = {
      id: 'mock-recipient-wallet-id',
      userId: recipient.id,
      VonBalance: 0, // Mock balance for testing
      balance: 0
    };
    console.log('üîç Transfer API: Using mock recipient wallet:', recipientWallet);

    // Create transfer record without complex database operations
    console.log('üìù Transfer API: Creating transfer record...');
    const transferId = randomUUID();
    const transfer = {
      id: transferId,
      senderId: senderUser.id,
      recipientId: recipient.id,
      senderEmail: session.email,
      recipientEmail: recipientEmail,
      amount: numericAmount,
      note: note || null,
      status: 'COMPLETED',
      createdAt: new Date().toISOString()
    };
    console.log('‚úÖ Transfer API: Transfer record created:', transfer.id);
    
    // Simulate successful transfer
    console.log('üéâ Transfer API: Transfer completed successfully');

    return NextResponse.json({
      success: true,
      message: 'Transfer successful',
      transfer: {
        id: transfer.id,
        amount: transfer.amount,
        recipientEmail: transfer.recipientEmail,
        note: transfer.note,
        createdAt: transfer.createdAt
      }
    });

  } catch (error) {
    console.error('‚ùå Transfer API Error:', {
      error: error.message,
      stack: error.stack,
      session: 'Session data not available in error handler',
      timestamp: new Date().toISOString()
    });
    return handleApiError(error, 'Failed to process transfer');
  }
}

// Public POST handler with global error catching
export async function POST(request) {
  try {
    return await handlePOST(request);
  } catch (error) {
    console.error('‚ùå Transfer API: Unhandled error:', error);
    return NextResponse.json({
      success: false,
      error: 'Internal server error',
      details: error.message,
      type: 'server_error',
      timestamp: new Date().toISOString()
    }, { status: 500 });
  }
}

export async function GET(request) {
  try {
    const session = await getServerSession();
    if (!session?.id) {
      return handleAuthError('Authentication required');
    }

    const transfers = await databaseHelpers.transfer.getUserTransfers(session.id);

    // Separate sent and received transfers
    const sentTransfers = transfers.filter(t => t.senderId === session.id);
    const receivedTransfers = transfers.filter(t => t.recipientId === session.id);

    return NextResponse.json({
      success: true,
      transfers: {
        sent: sentTransfers,
        received: receivedTransfers,
        all: transfers
      }
    });

  } catch (error) {
    return handleApiError(error, 'Failed to fetch transfers');
  }
}






